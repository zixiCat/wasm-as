<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>AssemblyScript isPrime demo</title>
</head>
<body>

<canvas id="canvas" style="width: 100%; height: 100%; background: #000; cursor: crosshair"></canvas>
<script>
    // Configuration
    const RGB_ALIVE = 0xD392E6;
    const RGB_DEAD  = 0xA61B85;
    const BIT_ROT   = 10;

    // Set up the canvas with a 2D rendering context
    const canvas = document.getElementById("canvas");
    const boundingRect = canvas.getBoundingClientRect();
    const ctx = canvas.getContext("2d");

    // Compute the size of the universe (2 pixels per cell)
    const width = boundingRect.width >>> 1;
    const height = boundingRect.height >>> 1;
    const size = width * height;
    const byteSize = (size + size) << 2; // input & output (4 bytes per cell)

    canvas.width = width;
    canvas.height = height;
    canvas.style.imageRendering = "pixelated";
    ctx.imageSmoothingEnabled = false;

    // Compute the size of and instantiate the module's memory
    const memory = new WebAssembly.Memory({ initial: ((byteSize + 0xffff) & ~0xffff) >>> 16 });

    // Fetch and instantiate the module
    loader.instantiate(module_wasm, {
        env: {
            memory
        },
        module: {
            BGR_ALIVE : rgb2bgr(RGB_ALIVE) | 1, // LSB set indicates alive
            BGR_DEAD  : rgb2bgr(RGB_DEAD) & ~1, // LSB not set indicates dead
            BIT_ROT
        }
    }).then(({ exports }) => {
        // Initialize the module with the universe's width and height
        exports.init(width, height);

        var buffer = new Uint32Array(memory.buffer);

        // Update about 30 times a second
        (function update() {
            setTimeout(update, 1000 / 30);
            buffer.copyWithin(0, size, size + size);   // copy output to input
            exports.step();                            // perform the next step
        })();

        // Keep rendering the output at [size, 2*size]
        var imageData = ctx.createImageData(width, height);
        var argb = new Uint32Array(imageData.data.buffer);
        (function render() {
            requestAnimationFrame(render);
            argb.set(buffer.subarray(size, size + size)); // copy output to image buffer
            ctx.putImageData(imageData, 0, 0);            // apply image buffer
        })();

        // When clicked or dragged, fill the current row and column with random live cells
        var down = false;
        [ [canvas, "mousedown"],
            [canvas, "touchstart"]
        ].forEach(eh => eh[0].addEventListener(eh[1], e => down = true));
        [ [document, "mouseup"],
            [document, "touchend"]
        ].forEach(eh => eh[0].addEventListener(eh[1], e => down = false));
        [ [canvas, "mousemove"],
            [canvas, "touchmove"],
            [canvas, "mousedown"]
        ].forEach(eh => eh[0].addEventListener(eh[1], e => {
            if (!down) return;
            var loc;
            if (e.touches) {
                if (e.touches.length > 1) return;
                loc = e.touches[0];
            } else {
                loc = e;
            }
            const currentBoundingRect = canvas.getBoundingClientRect();
            exports.fill(
                ((loc.clientX - currentBoundingRect.left) / currentBoundingRect.width * boundingRect.width) >>> 1,
                ((loc.clientY - currentBoundingRect.top) / currentBoundingRect.height * boundingRect.height) >>> 1,
                0.5
            );
        }));
    });

    /** Bitshifts an RGB color to BGR instead (WebAssembly is little endian). */
    function rgb2bgr(rgb) {
        return ((rgb >>> 16) & 0xff) | (rgb & 0xff00) | (rgb & 0xff) << 16;
    }
</script>


<!--<form id="prime-checker">-->
<!--    <label for="number">Enter a number to check if it is prime:</label>-->
<!--    <input name="number" type="number"/>-->
<!--    <button type="submit">Submit</button>-->
<!--</form>-->

<!--<p id="result"></p>-->

<!--<script src="./demo.js"></script>-->
</body>
</html>
